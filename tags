!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ASSUME	src/old/rbtree/misc.h	50;"	d
ASSUME	src/old/rbtree/misc.h	52;"	d
Assert	src/old/rbtree/misc.h	/^inline void Assert(int assertion, char* error) {$/;"	f
BILLION	src/old/test/file_rw_test.c	10;"	d	file:
BILLION	src/old/test/nvm_rw_test1.c	10;"	d	file:
BILLION	src/old/test/nvm_rw_test2.c	10;"	d	file:
BILLION	src/old/test/nvm_rw_test3.c	10;"	d	file:
BIN	Makefile	/^BIN = .\/bin\/$/;"	m
BLOCK_SIZE	include/nvm0common.h	6;"	d
Bottom	src/old/rbtree/TemplateStack.h	/^  inline Type * Bottom() const$/;"	f	class:TemplateStack
CC	Makefile	/^CC = g++$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -Wall -std=c++11$/;"	m
Capacity	src/old/rbtree/TemplateStack.h	/^  inline int Capacity() const $/;"	f	class:TemplateStack
CheckAssumptions	src/old/rbtree/RedBlackTree.cc	/^void RedBlackTree::CheckAssumptions() const {$/;"	f	class:RedBlackTree
Clear	src/old/rbtree/TemplateStack.h	/^  inline void Clear() { currentSize = 0;} \/\/ clears the TemplateStack$/;"	f	class:TemplateStack
Clear	src/old/rbtree/TemplateStack.h	/^  inline void Clear(void (*DestFunc)(Type ) ) $/;"	f	class:TemplateStack
DATA_START	include/nvm0common.h	/^    char*               DATA_START;$/;"	m	struct:_nvm_metadata
DEFAULT_INITIAL_SIZE	src/old/rbtree/TemplateStack.h	9;"	d
DELETE	src/old/rbtree/avl_ver_pointer.c	375;"	d	file:
DeleteAtPosition	src/old/rbtree/TemplateStack.h	/^  void DeleteAtPosition(const int position, const int size)$/;"	f	class:TemplateStack
DeleteAtPosition	src/old/rbtree/TemplateStack.h	/^  void DeleteAtPosition(int position) $/;"	f	class:TemplateStack
DeleteFixUp	src/old/rbtree/RedBlackTree.cc	/^void RedBlackTree::DeleteFixUp(RedBlackTreeNode* x) {$/;"	f	class:RedBlackTree
DeleteNode	src/old/rbtree/RedBlackTree.cc	/^RedBlackEntry * RedBlackTree::DeleteNode(RedBlackTreeNode * z){$/;"	f	class:RedBlackTree
DeleteTop	src/old/rbtree/TemplateStack.h	/^  inline void DeleteTop()$/;"	f	class:TemplateStack
Destroy	src/old/rbtree/TemplateStack.h	/^  void Destroy(void (*DestFunc)(Type) )$/;"	f	class:TemplateStack
E_REDBLACK_TREE	src/old/rbtree/RedBlackTree.h	2;"	d
E_TEMPLATE_STACK	src/old/rbtree/TemplateStack.h	2;"	d
Empty	src/old/rbtree/TemplateStack.h	/^  inline int Empty() const$/;"	f	class:TemplateStack
Enumerate	src/old/rbtree/RedBlackTree.cc	/^TemplateStack<RedBlackTreeNode *> * RedBlackTree::Enumerate(int low, $/;"	f	class:RedBlackTree
ExitProgramMacro	src/old/rbtree/misc.h	33;"	d
FREE_INODE_LIST_HEAD	include/nvm0common.h	/^    struct _nvm_inode*  FREE_INODE_LIST_HEAD;$/;"	m	struct:_nvm_metadata	typeref:struct:_nvm_metadata::_nvm_inode
FREE_INODE_LIST_TAIL	include/nvm0common.h	/^    struct _nvm_inode*  FREE_INODE_LIST_TAIL;$/;"	m	struct:_nvm_metadata	typeref:struct:_nvm_metadata::_nvm_inode
FREE_VTE_LIST_HEAD	include/nvm0common.h	/^    struct _vt_entry*   FREE_VTE_LIST_HEAD;$/;"	m	struct:_nvm_metadata	typeref:struct:_nvm_metadata::_vt_entry
FREE_VTE_LIST_TAIL	include/nvm0common.h	/^    struct _vt_entry*   FREE_VTE_LIST_TAIL;$/;"	m	struct:_nvm_metadata	typeref:struct:_nvm_metadata::_vt_entry
ForEachItemDo	src/old/rbtree/TemplateStack.h	/^  inline void ForEachItemDo(void (*function)(Type)) const$/;"	f	class:TemplateStack
ForEachItemDo	src/old/rbtree/TemplateStack.h	/^  inline void ForEachItemDo(void (*function)(Type, void * controller),$/;"	f	class:TemplateStack
GetAddressOfArray	src/old/rbtree/TemplateStack.h	/^  inline Type * GetAddressOfArray() const { return arrayData; }$/;"	f	class:TemplateStack
GetEntry	src/old/rbtree/RedBlackTree.cc	/^RedBlackEntry * RedBlackTreeNode::GetEntry() const {return storedEntry;}$/;"	f	class:RedBlackTreeNode
GetIndexOf	src/old/rbtree/TemplateStack.h	/^  inline int GetIndexOf(Type const & possibleMemberOfStack) const$/;"	f	class:TemplateStack
GetPredecessorOf	src/old/rbtree/RedBlackTree.cc	/^RedBlackTreeNode * RedBlackTree::GetPredecessorOf(RedBlackTreeNode * x) const {$/;"	f	class:RedBlackTree
GetSuccessorOf	src/old/rbtree/RedBlackTree.cc	/^RedBlackTreeNode * RedBlackTree::GetSuccessorOf(RedBlackTreeNode * x) const$/;"	f	class:RedBlackTree
INCLUDE	Makefile	/^INCLUDE = .\/include$/;"	m
INC_E_MISC_DOT_H	src/old/rbtree/misc.h	2;"	d
INODE_START	include/nvm0common.h	/^    struct _nvm_inode*  INODE_START;$/;"	m	struct:_nvm_metadata	typeref:struct:_nvm_metadata::_nvm_inode
INODE_STATE_ALLOCATED	include/nvm0common.h	10;"	d
INODE_STATE_FREE	include/nvm0common.h	9;"	d
INODE_STATE_SYNCED	include/nvm0common.h	12;"	d
INODE_STATE_WRITTEN	include/nvm0common.h	11;"	d
INSERT	src/old/rbtree/avl_ver_pointer.c	374;"	d	file:
IndexOfTop	src/old/rbtree/TemplateStack.h	/^  inline int IndexOfTop() const$/;"	f	class:TemplateStack
Insert	src/old/rbtree/RedBlackTree.cc	/^RedBlackTreeNode * RedBlackTree::Insert(RedBlackEntry * newEntry)$/;"	f	class:RedBlackTree
InsertAtPosition	src/old/rbtree/TemplateStack.h	/^  void InsertAtPosition(const  int position,$/;"	f	class:TemplateStack
InsertAtPosition	src/old/rbtree/TemplateStack.h	/^  void InsertAtPosition(const int position, const Type itemToInsert)$/;"	f	class:TemplateStack
ItemAtTop	src/old/rbtree/TemplateStack.h	/^  inline Type & ItemAtTop() const $/;"	f	class:TemplateStack
LFqueue	src/nvm0lfq.h	/^LFqueue<T>::LFqueue(uint32_t size) :$/;"	f	class:LFqueue
LFqueue	src/nvm0lfq.h	/^class LFqueue {$/;"	c
LIB	Makefile	/^LIB = .\/lib$/;"	m
LIBNAME	Makefile	/^LIBNAME = -lpthread -lrt$/;"	m
LeftRotate	src/old/rbtree/RedBlackTree.cc	/^void RedBlackTree::LeftRotate(RedBlackTreeNode* x) {$/;"	f	class:RedBlackTree
MAX_BUF_SIZE	src/old/test/file_rw_test.c	11;"	d	file:
MAX_BUF_SIZE	src/old/test/nvm_rw_test1.c	11;"	d	file:
MAX_BUF_SIZE	src/old/test/nvm_rw_test2.c	11;"	d	file:
MAX_BUF_SIZE	src/old/test/nvm_rw_test3.c	11;"	d	file:
MAX_BUF_SIZE	src/test/test1.c	/^unsigned int MAX_BUF_SIZE = 512*1024*1024;$/;"	v
MAX_INT	src/old/rbtree/RedBlackTree.h	26;"	d
MAX_NVM_INODE	include/nvm0common.h	5;"	d
MAX_VT_ENTRY	include/nvm0common.h	4;"	d
MIN_INT	src/old/rbtree/RedBlackTree.cc	/^const int MIN_INT=-MAX_INT;$/;"	v
Max	src/nvm0avltree.c	/^Max($/;"	f
Max	src/old/rbtree/avl_ver_pointer.c	/^int Max(int a, int b) { return a > b ? a : b; }$/;"	f
Member	src/old/rbtree/TemplateStack.h	/^  inline Type * Member(Type const & possibleMemberOfStack)$/;"	f	class:TemplateStack
NVM	src/nvm0nvm.c	/^NVM_metadata* NVM;$/;"	v
NVM_inode	include/nvm0common.h	/^} NVM_inode;$/;"	t	typeref:struct:_nvm_inode
NVM_metadata	include/nvm0common.h	/^} NVM_metadata;$/;"	t	typeref:struct:_nvm_metadata
NotEmpty	src/old/rbtree/TemplateStack.h	/^  inline int NotEmpty() const$/;"	f	class:TemplateStack
NullFunction	src/old/rbtree/misc.h	/^inline void NullFunction(const void * ) { ; }$/;"	f
NullFunction	src/old/rbtree/misc.h	/^inline void NullFunction(void * ) { ; }$/;"	f
OBJS	Makefile	/^OBJS = .\/src\/nvm0nvm.o .\/src\/nvm0lfq.o .\/src\/nvm0write.o .\/src\/nvm0flush.o .\/src\/nvm0avltree.o .\/src\/test\/test1.o$/;"	m
PRINTFREELIST	src/old/rbtree/avl_ver_pointer.c	376;"	d	file:
PRINTTREE	src/old/rbtree/avl_ver_pointer.c	377;"	d	file:
Pop	src/old/rbtree/TemplateStack.h	/^  inline Type Pop()$/;"	f	class:TemplateStack
Print	src/old/rbtree/RedBlackTree.cc	/^void RedBlackEntry::Print() const {$/;"	f	class:RedBlackEntry
Print	src/old/rbtree/RedBlackTree.cc	/^void RedBlackTree::Print() const {$/;"	f	class:RedBlackTree
Print	src/old/rbtree/RedBlackTree.cc	/^void RedBlackTreeNode::Print(RedBlackTreeNode * nil,$/;"	f	class:RedBlackTreeNode
PrintTree	src/old/rbtree/avl_ver_pointer.c	/^void PrintTree(struct node *root) {$/;"	f
Push	src/old/rbtree/TemplateStack.h	/^  void Push(Type newInfo)$/;"	f	class:TemplateStack
Push	src/old/rbtree/TemplateStack.h	/^  void Push(const TemplateStack<Type> & stackToAdd)$/;"	f	class:TemplateStack
Push	src/old/rbtree/TemplateStack.h	/^  void Push(const TemplateStack<Type> * const stackToAdd)$/;"	f	class:TemplateStack
QUIT	src/old/rbtree/avl_ver_pointer.c	378;"	d	file:
RedBlackEntry	src/old/rbtree/RedBlackTree.cc	/^RedBlackEntry::RedBlackEntry(){$/;"	f	class:RedBlackEntry
RedBlackEntry	src/old/rbtree/RedBlackTree.h	/^class RedBlackEntry {$/;"	c
RedBlackTree	src/old/rbtree/RedBlackTree.cc	/^RedBlackTree::RedBlackTree()$/;"	f	class:RedBlackTree
RedBlackTree	src/old/rbtree/RedBlackTree.h	/^class RedBlackTree {$/;"	c
RedBlackTreeNode	src/old/rbtree/RedBlackTree.cc	/^RedBlackTreeNode::RedBlackTreeNode(){$/;"	f	class:RedBlackTreeNode
RedBlackTreeNode	src/old/rbtree/RedBlackTree.cc	/^RedBlackTreeNode::RedBlackTreeNode(RedBlackEntry * newEntry)$/;"	f	class:RedBlackTreeNode
RedBlackTreeNode	src/old/rbtree/RedBlackTree.h	/^class RedBlackTreeNode {$/;"	c
RemoveAtIndex	src/old/rbtree/TemplateStack.h	/^  inline void RemoveAtIndex(int position)$/;"	f	class:TemplateStack
RightRotate	src/old/rbtree/RedBlackTree.cc	/^void RedBlackTree::RightRotate(RedBlackTreeNode* y) {$/;"	f	class:RedBlackTree
SHM_KEY	src/test/config.h	9;"	d
SHM_SIZE	src/test/config.h	10;"	d
SRCS	Makefile	/^SRCS = .\/src\/$(OBJS:.o=.c)$/;"	m
SYNC_INODE_LIST_HEAD	include/nvm0common.h	/^    struct _nvm_inode*  SYNC_INODE_LIST_HEAD;$/;"	m	struct:_nvm_metadata	typeref:struct:_nvm_metadata::_nvm_inode
SYNC_INODE_LIST_TAIL	include/nvm0common.h	/^    struct _nvm_inode*  SYNC_INODE_LIST_TAIL;$/;"	m	struct:_nvm_metadata	typeref:struct:_nvm_metadata::_nvm_inode
SafeCalloc	src/old/rbtree/misc.h	/^inline void * SafeCalloc(int numberOfElements , size_t size) {$/;"	f
SafeMalloc	src/old/rbtree/misc.h	/^inline void * SafeMalloc(size_t size) {$/;"	f
SetCurrentSize	src/old/rbtree/TemplateStack.h	/^  inline void SetCurrentSize(const int newSize)$/;"	f	class:TemplateStack
Size	src/old/rbtree/TemplateStack.h	/^  inline int Size() const $/;"	f	class:TemplateStack
SpecialRealloc	src/old/rbtree/TemplateStack.h	/^  inline Type * SpecialRealloc(Type * arrayData, int size) $/;"	f	class:TemplateStack
SwapTwoElements	src/old/rbtree/TemplateStack.h	/^  inline void SwapTwoElements(int first , int second)$/;"	f	class:TemplateStack
TemplateStack	src/old/rbtree/TemplateStack.h	/^  TemplateStack(TemplateStack const & originalStack)$/;"	f	class:TemplateStack
TemplateStack	src/old/rbtree/TemplateStack.h	/^  TemplateStack(int size = DEFAULT_INITIAL_SIZE)$/;"	f	class:TemplateStack
TemplateStack	src/old/rbtree/TemplateStack.h	/^class TemplateStack {$/;"	c
Top	src/old/rbtree/TemplateStack.h	/^  inline Type * Top() const$/;"	f	class:TemplateStack
TreeInsertHelp	src/old/rbtree/RedBlackTree.cc	/^void RedBlackTree::TreeInsertHelp(RedBlackTreeNode* z) {$/;"	f	class:RedBlackTree
TreePrintHelper	src/old/rbtree/RedBlackTree.cc	/^void RedBlackTree::TreePrintHelper( RedBlackTreeNode* x) const {$/;"	f	class:RedBlackTree
VERIFY	src/old/rbtree/misc.h	43;"	d
VOL_TABLE_START	include/nvm0common.h	/^    struct _vt_entry*   VOL_TABLE_START;$/;"	m	struct:_nvm_metadata	typeref:struct:_nvm_metadata::_vt_entry
VT_entry	include/nvm0common.h	/^} VT_entry;$/;"	t	typeref:struct:_vt_entry
__CONFIG_H_	src/test/config.h	2;"	d
__NVM_COMMON_H_	include/nvm0common.h	2;"	d
__NVM_LFQUEUE_	src/nvm0lfq.h	2;"	d
_nvm_inode	include/nvm0common.h	/^typedef struct _nvm_inode {$/;"	s
_nvm_metadata	include/nvm0common.h	/^typedef struct _nvm_metadata {$/;"	s
_vt_entry	include/nvm0common.h	/^typedef struct _vt_entry {$/;"	s
alloc_nvm_inode	src/backup/nvm0write.c	/^alloc_nvm_inode($/;"	f
alloc_nvm_inode	src/nvm0write.c	/^alloc_nvm_inode($/;"	f
alloc_vt_entry	src/backup/nvm0write.c	/^alloc_vt_entry($/;"	f
alloc_vt_entry	src/nvm0write.c	/^alloc_vt_entry($/;"	f
allocateNode	src/old/rbtree/avl_ver_pointer.c	/^struct node *allocateNode(int vid)$/;"	f
arrayData	src/old/rbtree/TemplateStack.h	/^  Type * arrayData;$/;"	m	class:TemplateStack
c_count	src/nvm0lfq.h	/^    std::atomic<uint64_t> c_count; \/* <out: global consumer counter *\/$/;"	m	class:LFqueue
currentSize	src/old/rbtree/TemplateStack.h	/^  int currentSize;$/;"	m	class:TemplateStack
data_dump	src/test/dumpcode.h	/^data_dump($/;"	f
deallocateNode	src/old/rbtree/avl_ver_pointer.c	/^void deallocateNode(struct node *root)$/;"	f
delete	src/old/rbtree/avl_ver_pointer.c	/^struct node* delete(struct node* root, struct node* vte)$/;"	f
dequeue	src/nvm0lfq.h	/^T& LFqueue<T>::dequeue(void)$/;"	f	class:LFqueue
enqueue	src/nvm0lfq.h	/^void LFqueue<T>::enqueue(const T& inode)$/;"	f	class:LFqueue
f_next	include/nvm0common.h	/^    unsigned int        f_next;$/;"	m	struct:_nvm_inode
f_prev	include/nvm0common.h	/^    unsigned int        f_prev;$/;"	m	struct:_nvm_inode
fd	include/nvm0common.h	/^    int                 fd;     \/\/ file descriptor (useless when recovery)$/;"	m	struct:_vt_entry
fd	src/old/test/file_rw_test.c	/^int fd;$/;"	v
fd	src/old/test/nvm_rw_test1.c	/^int fd;$/;"	v
fd	src/old/test/nvm_rw_test2.c	/^int fd;$/;"	v
fd	src/old/test/nvm_rw_test3.c	/^int fd;$/;"	v
filename	src/old/test/file_rw_test.c	/^char* filename = "VOL0000.txt";$/;"	v
filename	src/old/test/nvm_rw_test1.c	/^char* filename = "VOL0001.txt";$/;"	v
filename	src/old/test/nvm_rw_test2.c	/^char* filename = "VOL0002.txt";$/;"	v
filename	src/old/test/nvm_rw_test3.c	/^char* filename = "VOL0003.txt";$/;"	v
fill_buf	src/old/test/file_rw_test.c	/^void fill_buf(char *buf, int size)$/;"	f
fill_buf	src/old/test/nvm_rw_test1.c	/^void fill_buf(char *buf, int size)$/;"	f
fill_buf	src/old/test/nvm_rw_test2.c	/^void fill_buf(char *buf, int size)$/;"	f
fill_buf	src/old/test/nvm_rw_test3.c	/^void fill_buf(char *buf, int size)$/;"	f
fill_buf	src/test/test1.c	/^fill_buf($/;"	f
find	src/old/rbtree/avl_ver_pointer.c	/^struct node *find(struct node *root, int vid)$/;"	f
freeList	src/old/rbtree/avl_ver_pointer.c	/^struct node *freeList;$/;"	v	typeref:struct:node
freeList_head	src/old/rbtree/avl_ver_pointer.c	/^struct node *freeList_head;$/;"	v	typeref:struct:node
getBalance	src/nvm0avltree.c	/^getBalance($/;"	f
getBalance	src/old/rbtree/avl_ver_pointer.c	/^int getBalance(struct node *N)$/;"	f
get_filename	src/backup/nvm0write.c	/^get_filename($/;"	f
get_filename	src/nvm0write.c	/^get_filename($/;"	f
get_free_inode_num	src/nvm0nvm.c	/^get_free_inode_num()$/;"	f
get_free_vte_num	src/nvm0nvm.c	/^get_free_vte_num()$/;"	f
get_nvm_inode	src/backup/nvm0write.c	/^get_nvm_inode($/;"	f
get_nvm_inode	src/nvm0write.c	/^get_nvm_inode($/;"	f
get_nvm_inode_idx	src/nvm0nvm.c	/^get_nvm_inode_idx($/;"	f
get_sync_inode_num	src/nvm0nvm.c	/^get_sync_inode_num()$/;"	f
get_vt_entry	src/backup/nvm0write.c	/^get_vt_entry($/;"	f
get_vt_entry	src/nvm0write.c	/^get_vt_entry($/;"	f
height	include/nvm0common.h	/^    int                 height;$/;"	m	struct:_nvm_inode
height	src/nvm0avltree.c	/^height($/;"	f
height	src/old/rbtree/avl_ver_pointer.c	/^	int height;$/;"	m	struct:node	file:
height	src/old/rbtree/avl_ver_pointer.c	/^int height(struct node *N)$/;"	f
initFreeList	src/old/rbtree/avl_ver_pointer.c	/^void initFreeList(void)$/;"	f
init_nvm_address	src/nvm0nvm.c	/^init_nvm_address($/;"	f
insert	src/old/rbtree/avl_ver_pointer.c	/^struct node* insert(struct node *node, struct node *vte)$/;"	f
insert_nvm_inode	src/nvm0avltree.c	/^insert_nvm_inode($/;"	f
insert_sync_inode_list	src/backup/nvm0write.c	/^insert_sync_inode_list($/;"	f
insert_sync_inode_list	src/nvm0write.c	/^insert_sync_inode_list($/;"	f
iroot	include/nvm0common.h	/^    struct _nvm_inode*  iroot;  \/\/ inode root$/;"	m	struct:_vt_entry	typeref:struct:_vt_entry::_nvm_inode
key	src/old/rbtree/RedBlackTree.h	/^  int key;$/;"	m	class:RedBlackTreeNode
key	src/old/rbtree/avl_ver_pointer.c	/^	int key; \/\/ can be vid or lbn$/;"	m	struct:node	file:
lbn	include/nvm0common.h	/^    unsigned int        lbn;      \/\/ logical block number$/;"	m	struct:_nvm_inode
left	include/nvm0common.h	/^    struct _nvm_inode*  left;$/;"	m	struct:_nvm_inode	typeref:struct:_nvm_inode::_nvm_inode
left	src/old/rbtree/RedBlackTree.h	/^  RedBlackTreeNode * left;$/;"	m	class:RedBlackTreeNode
left	src/old/rbtree/avl_ver_pointer.c	/^	struct node *left;$/;"	m	struct:node	typeref:struct:node::node	file:
leftRotate	src/nvm0avltree.c	/^leftRotate($/;"	f
leftRotate	src/old/rbtree/avl_ver_pointer.c	/^struct node *leftRotate(struct node *x)$/;"	f
lp_count	src/nvm0lfq.h	/^    std::atomic<uint64_t>* lp_count; \/* <out: local producer counter for each lfqueue element *\/$/;"	m	class:LFqueue
main	src/old/rbtree/avl_ver_pointer.c	/^int main()$/;"	f
main	src/old/test/file_rw_test.c	/^int main(int argc, char *argv[])$/;"	f
main	src/old/test/nvm_rw_test1.c	/^int main(int argc, char *argv[])$/;"	f
main	src/old/test/nvm_rw_test2.c	/^int main(int argc, char *argv[])$/;"	f
main	src/old/test/nvm_rw_test3.c	/^int main(int argc, char *argv[])$/;"	f
main	src/test/shm-remove.c	/^main()$/;"	f
main	src/test/test1.c	/^main($/;"	f
maxSize	src/old/rbtree/TemplateStack.h	/^  int maxSize;$/;"	m	class:TemplateStack
minValueNode	src/old/rbtree/avl_ver_pointer.c	/^struct node* minValueNode(struct node* node)$/;"	f
mutex	src/old/test/file_rw_test.c	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
mutex	src/old/test/nvm_rw_test1.c	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
mutex	src/old/test/nvm_rw_test2.c	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
mutex	src/old/test/nvm_rw_test3.c	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
newNode	src/old/rbtree/avl_ver_pointer.c	/^struct node* newNode(int key)$/;"	f
next	include/nvm0common.h	/^    unsigned int next;$/;"	m	struct:_vt_entry
next	src/old/rbtree/avl_ver_pointer.c	/^	struct node *next; \/\/ freelist$/;"	m	struct:node	typeref:struct:node::node	file:
nil	src/old/rbtree/RedBlackTree.h	/^  RedBlackTreeNode * nil;$/;"	m	class:RedBlackTree
node	src/old/rbtree/avl_ver_pointer.c	/^struct node$/;"	s	file:
nvm_atomic_write	src/backup/nvm0write.c	/^nvm_atomic_write($/;"	f
nvm_atomic_write	src/nvm0write.c	/^nvm_atomic_write($/;"	f
nvm_sync	src/nvm0flush.c	/^nvm_sync()$/;"	f
nvm_system_init	src/nvm0nvm.c	/^nvm_system_init()$/;"	f
operator <<	src/old/rbtree/TemplateStack.h	/^ostream & operator<<(ostream & s, TemplateStack<Type> & theStack) $/;"	f
operator =	src/old/rbtree/TemplateStack.h	/^  TemplateStack const & operator=(TemplateStack const & stackToCopy)$/;"	f	class:TemplateStack
operator []	src/old/rbtree/TemplateStack.h	/^  inline Type & operator[](int k) const$/;"	f	class:TemplateStack
p_count	src/nvm0lfq.h	/^    std::atomic<uint64_t> p_count; \/* <out: global producer counter *\/$/;"	m	class:LFqueue
parent	src/old/rbtree/RedBlackTree.h	/^  RedBlackTreeNode * parent;$/;"	m	class:RedBlackTreeNode
printFreeList	src/old/rbtree/avl_ver_pointer.c	/^void printFreeList()$/;"	f
print_nvm_info	src/nvm0nvm.c	/^print_nvm_info()$/;"	f
printchar	src/test/dumpcode.h	/^printchar($/;"	f
q_size	src/nvm0lfq.h	/^    uint32_t q_size; \/* <in: size of lfqueue *\/$/;"	m	class:LFqueue
queue	src/nvm0lfq.h	/^    T* queue; \/* <out: lfqueue array *\/$/;"	m	class:LFqueue
red	src/old/rbtree/RedBlackTree.h	/^  int red; \/* if red=0 then the node is black *\/$/;"	m	class:RedBlackTreeNode
right	include/nvm0common.h	/^    struct _nvm_inode*  right;$/;"	m	struct:_nvm_inode	typeref:struct:_nvm_inode::_nvm_inode
right	src/old/rbtree/RedBlackTree.h	/^  RedBlackTreeNode * right;$/;"	m	class:RedBlackTreeNode
right	src/old/rbtree/avl_ver_pointer.c	/^	struct node *right;$/;"	m	struct:node	typeref:struct:node::node	file:
rightRotate	src/nvm0avltree.c	/^rightRotate($/;"	f
rightRotate	src/old/rbtree/avl_ver_pointer.c	/^struct node *rightRotate(struct node *y)$/;"	f
root	src/old/rbtree/RedBlackTree.h	/^  RedBlackTreeNode * root;$/;"	m	class:RedBlackTree
s_next	include/nvm0common.h	/^    struct _nvm_inode*  s_next;$/;"	m	struct:_nvm_inode	typeref:struct:_nvm_inode::_nvm_inode
s_prev	include/nvm0common.h	/^    struct _nvm_inode*  s_prev;$/;"	m	struct:_nvm_inode	typeref:struct:_nvm_inode::_nvm_inode
search_nvm_inode	src/nvm0avltree.c	/^search_nvm_inode($/;"	f
search_vt_entry	src/backup/nvm0write.c	/^search_vt_entry($/;"	f
search_vt_entry	src/nvm0write.c	/^search_vt_entry($/;"	f
state	include/nvm0common.h	/^    int                 state;    \/\/ state of block$/;"	m	struct:_nvm_inode
state	src/old/rbtree/avl_ver_pointer.c	/^	int state; \/\/ allocated or not$/;"	m	struct:node	file:
storedEntry	src/old/rbtree/RedBlackTree.h	/^  RedBlackEntry * storedEntry;$/;"	m	class:RedBlackTreeNode
thread_func	src/old/test/file_rw_test.c	/^void *thread_func(void *data)$/;"	f
thread_func	src/old/test/nvm_rw_test1.c	/^void *thread_func(void *data)$/;"	f
thread_func	src/old/test/nvm_rw_test2.c	/^void *thread_func(void *data)$/;"	f
thread_func	src/old/test/nvm_rw_test3.c	/^void *thread_func(void *data)$/;"	f
thread_sync_func	src/test/test1.c	/^thread_sync_func($/;"	f
thread_write_func	src/test/test1.c	/^*thread_write_func($/;"	f
vid	include/nvm0common.h	/^    unsigned int        vid;    \/\/ volume id (implicit filename)$/;"	m	struct:_vt_entry
vte	include/nvm0common.h	/^    struct _vt_entry*   vte;      \/\/ volume id (implicit filename)$/;"	m	struct:_nvm_inode	typeref:struct:_nvm_inode::_vt_entry
~LFqueue	src/nvm0lfq.h	/^LFqueue<T>::~LFqueue(void)$/;"	f	class:LFqueue
~RedBlackEntry	src/old/rbtree/RedBlackTree.cc	/^RedBlackEntry::~RedBlackEntry(){$/;"	f	class:RedBlackEntry
~RedBlackTree	src/old/rbtree/RedBlackTree.cc	/^RedBlackTree::~RedBlackTree() {$/;"	f	class:RedBlackTree
~RedBlackTreeNode	src/old/rbtree/RedBlackTree.cc	/^RedBlackTreeNode::~RedBlackTreeNode(){$/;"	f	class:RedBlackTreeNode
~TemplateStack	src/old/rbtree/TemplateStack.h	/^  ~TemplateStack()$/;"	f	class:TemplateStack
